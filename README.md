# Общая картина
Код состоит из двух частей:

_Main_ - клиентский код, который использует связный список

_MyLinkedList_ - реализация односвязного списка

Пошаговый разбор выполнения _main()_
Шаг 1: Создание списка

    java
    MyLinkedList<Integer> list = new MyLinkedList<>();

Состояние списка:

    head = null
    
    size = 0

Список пустой: []

Шаг 2: Добавление элементов в конец

    java
    list.addLast(198);
    list.addLast(12);
    После addLast(198):

Создается узел _Node(198)_

head указывает на этот узел

size = 1

Список: [198]

После addLast(12):

Создается узел Node(12)

Находим последний узел (198) и устанавливаем ему next = Node(12)

size = 2

Список: [198] → [12]

Шаг 3: Чтение элементов

    java
    list.get(1);  // возвращает 12
    list.get(0);  // возвращает 198

Как работает get(int index):

get(0): берем head.element = 198

get(1): идем от head к next узлу, берем element = 12

Шаг 4: Добавление по индексу

      java
      list.add(2, 18);  // добавляем на позицию 2
      list.add(3, 87);  // добавляем на позицию 3
      

После _add(2, 18)_:

Находим узел с индексом 1 (это узел со значением 12)

Создаем новый узел _Node(18)_ который указывает на _null_ (так как был конец списка)

Устанавливаем 12.next = Node(18)

Список: [198] → [12] → [18]

size = 3

После _add(3, 871)_:

Находим узел с индексом 2 (это узел со значением 18)

Создаем новый узел Node(87) который указывает на null

Устанавливаем 18.next = Node(87)

Список: [198] → [12] → [18] → [87]

size = 4

Шаг 5: Удаление последнего элемента

    java
    list.removeLast();

Как работает removeLast():

current и temp указывают на head (198)

Идем до конца списка:

temp = 198, current = 12

temp = 12, current = 18

temp = 18, current = 87 (current.next == null - остановка)

current = temp - теперь current указывает на узел 18

current.next = null - обрываем связь с последним узлом

Узел 87 теряется (собирается garbage collector)
